/**
 * Admin Service
 * Comprehensive service for platform administration and management
 * Handles user management, contest oversight, payment monitoring, Oracle tuning, and analytics
 */

import { contestScoringService } from './contestScoringService';
import { productionSportsDataService } from './productionSportsDataService';
import { logger } from './loggingService';

// Admin interfaces
type SeverityLevel = 'low' | 'medium' | 'high' | 'critical';
type HealthStatus = 'healthy' | 'warning' | 'critical';

export interface AdminUser {
  id: string;
  username: string;
  email: string;
  role: 'admin' | 'moderator' | 'support';
  permissions: AdminPermission[];
  createdAt: string;
  lastLogin?: string;
  isActive: boolean;
}

export interface AdminPermission {
  resource: 'users' | 'contests' | 'payments' | 'oracle' | 'analytics' | 'system';
  actions: ('read' | 'write' | 'delete' | 'execute')[];
}

export interface UserSummary {
  id: string;
  username: string;
  email: string;
  status: 'active' | 'suspended' | 'banned' | 'pending';
  joinDate: string;
  lastLogin?: string;
  totalContests: number;
  totalSpent: number;
  totalWinnings: number;
  accountBalance: number;
  riskScore: number;
  flags: UserFlag[];
}

export interface UserFlag {
  type: 'payment_issue' | 'suspicious_activity' | 'multiple_accounts' | 'underage' | 'self_exclusion';
  severity: SeverityLevel;
  description: string;
  createdAt: string;
  resolvedAt?: string;
}

export interface ContestSummary {
  id: string;
  name: string;
  type: string;
  status: 'pending' | 'active' | 'completed' | 'cancelled';
  participantCount: number;
  maxParticipants: number;
  entryFee: number;
  prizePool: number;
  startDate: string;
  endDate: string;
  creator: string;
  flags: ContestFlag[];
}

export interface ContestFlag {
  type: 'low_participation' | 'payout_issue' | 'disputed_result' | 'technical_error';
  severity: SeverityLevel;
  description: string;
  createdAt: string;
}

export interface PaymentSummary {
  id: string;
  userId: string;
  type: 'deposit' | 'withdrawal' | 'contest_entry' | 'prize_payout' | 'refund';
  amount: number;
  currency: string;
  status: 'pending' | 'processing' | 'completed' | 'failed' | 'disputed';
  method: string;
  createdAt: string;
  processedAt?: string;
  flags: PaymentFlag[];
}

export interface PaymentFlag {
  type: 'fraud_risk' | 'chargeback_risk' | 'large_amount' | 'unusual_pattern' | 'verification_needed';
  severity: SeverityLevel;
  description: string;
  autoGenerated: boolean;
}

export interface OracleMetrics {
  totalPredictions: number;
  accuracyRate: number;
  averageConfidence: number;
  apiUsage: {
    requests: number;
    successRate: number;
    avgResponseTime: number;
    errorRate: number;
  };
  performanceByCategory: {
    [category: string]: {
      predictions: number;
      accuracy: number;
      confidence: number;
    };
  };
  userEngagement: {
    followingOracle: number;
    averageAgreementRate: number;
    oracleBeatRate: number;
  };
}

export interface SystemMetrics {
  uptime: number;
  activeUsers: number;
  totalUsers: number;
  activeContests: number;
  totalRevenue: number;
  todayRevenue: number;
  systemHealth: {
    database: HealthStatus;
    apis: HealthStatus;
    payments: HealthStatus;
    oracle: HealthStatus;
  };
  errors: SystemError[];
}

export interface SystemError {
  id: string;
  type: 'database' | 'api' | 'payment' | 'oracle' | 'auth' | 'unknown';
  severity: SeverityLevel;
  message: string;
  stack?: string;
  count: number;
  firstOccurrence: string;
  lastOccurrence: string;
  resolved: boolean;
}

export interface AdminDashboardData {
  overview: {
    totalUsers: number;
    activeUsers: number;
    totalContests: number;
    activeContests: number;
    totalRevenue: number;
    todayRevenue: number;
    pendingIssues: number;
    systemHealth: HealthStatus;
  };
  recentActivity: {
    newUsers: UserSummary[];
    recentContests: ContestSummary[];
    recentPayments: PaymentSummary[];
    systemAlerts: SystemError[];
  };
  metrics: {
    userGrowth: { date: string; count: number }[];
    revenueGrowth: { date: string; amount: number }[];
    contestParticipation: { date: string; participants: number }[];
    oracleAccuracy: { date: string; accuracy: number }[];
  };
}

class AdminService {
  private readonly adminUsers: Map<string, AdminUser> = new Map();
  private readonly userDatabase: Map<string, UserSummary> = new Map();
  private readonly systemErrors: SystemError[] = [];
  private readonly startTime = Date.now();

  constructor() {
    this.initializeAdminData();
  }

  private initializeAdminData(): void {
    // Initialize with default admin user
    const defaultAdmin: AdminUser = {
      id: 'admin_001',
      username: 'admin',
      email: 'admin@astraldraft.com',
      role: 'admin',
      permissions: [
        { resource: 'users', actions: ['read', 'write', 'delete'] },
        { resource: 'contests', actions: ['read', 'write', 'delete', 'execute'] },
        { resource: 'payments', actions: ['read', 'write', 'execute'] },
        { resource: 'oracle', actions: ['read', 'write', 'execute'] },
        { resource: 'analytics', actions: ['read'] },
        { resource: 'system', actions: ['read', 'write', 'execute'] }
      ],
      createdAt: new Date().toISOString(),
      lastLogin: new Date().toISOString(),
      isActive: true
    };

    this.adminUsers.set(defaultAdmin.id, defaultAdmin);

    // Initialize sample user data
    this.initializeSampleUsers();
  }

  private initializeSampleUsers(): void {
    const sampleUsers: UserSummary[] = [
      {
        id: 'user_001',
        username: 'ProPredictor',
        email: 'pro@example.com',
        status: 'active',
        joinDate: '2024-01-15T00:00:00Z',
        lastLogin: '2024-12-20T15:30:00Z',
        totalContests: 25,
        totalSpent: 500,
        totalWinnings: 750,
        accountBalance: 250,
        riskScore: 2,
        flags: []
      },
      {
        id: 'user_002',
        username: 'NFLFan2024',
        email: 'fan@example.com',
        status: 'active',
        joinDate: '2024-03-10T00:00:00Z',
        lastLogin: '2024-12-19T09:15:00Z',
        totalContests: 12,
        totalSpent: 240,
        totalWinnings: 180,
        accountBalance: 50,
        riskScore: 1,
        flags: []
      },
      {
        id: 'user_003',
        username: 'SuspiciousUser',
        email: 'suspicious@example.com',
        status: 'suspended',
        joinDate: '2024-12-01T00:00:00Z',
        lastLogin: '2024-12-18T22:45:00Z',
        totalContests: 3,
        totalSpent: 1500,
        totalWinnings: 0,
        accountBalance: 0,
        riskScore: 8,
        flags: [
          {
            type: 'suspicious_activity',
            severity: 'high',
            description: 'Unusual betting patterns detected',
            createdAt: '2024-12-18T10:00:00Z'
          },
          {
            type: 'payment_issue',
            severity: 'medium',
            description: 'Chargeback initiated',
            createdAt: '2024-12-17T14:30:00Z'
          }
        ]
      }
    ];

    sampleUsers.forEach(user => {
      this.userDatabase.set(user.id, user);
    });
  }

  /**
   * Admin Authentication and Authorization
   */
  async authenticateAdmin(username: string, password: string): Promise<AdminUser | null> {
    // In production, this would verify against secure storage
    // For now, returning the admin user if credentials match
    if (username === 'admin' && password === 'admin123') {
      const admin = Array.from(this.adminUsers.values()).find(u => u.username === username);
      if (admin) {
        admin.lastLogin = new Date().toISOString();
        return admin;
      }
    }
    return null;
  }

  checkAdminPermission(adminId: string, resource: string, action: string): boolean {
    const admin = this.adminUsers.get(adminId);
    if (!admin?.isActive) return false;

    const permission = admin.permissions.find(p => p.resource === resource);
    return permission ? permission.actions.includes(action as 'read' | 'write' | 'delete' | 'execute') : false;
  }

  /**
   * User Management
   */
  async getAllUsers(page: number = 1, limit: number = 50, filters?: {
    status?: string;
    riskLevel?: string;
    joinDateFrom?: string;
    joinDateTo?: string;
    searchTerm?: string;
  }): Promise<{ users: UserSummary[]; total: number; page: number; totalPages: number }> {
    let users = Array.from(this.userDatabase.values());

    // Apply filters
    if (filters) {
      if (filters.status) {
        users = users.filter(u => u.status === filters.status);
      }
      if (filters.riskLevel) {
        let riskThreshold: number;
        if (filters.riskLevel === 'high') {
          riskThreshold = 7;
        } else if (filters.riskLevel === 'medium') {
          riskThreshold = 4;
        } else {
          riskThreshold = 0;
        }
        users = users.filter(u => u.riskScore >= riskThreshold);
      }
      if (filters.searchTerm) {
        const term = filters.searchTerm.toLowerCase();
        users = users.filter(u => 
          u.username.toLowerCase().includes(term) || 
          u.email.toLowerCase().includes(term)
        );
      }
    }

    const total = users.length;
    const totalPages = Math.ceil(total / limit);
    const startIndex = (page - 1) * limit;
    const paginatedUsers = users.slice(startIndex, startIndex + limit);

    return {
      users: paginatedUsers,
      total,
      page,
      totalPages
    };
  }

  async getUserDetails(userId: string): Promise<UserSummary | null> {
    return this.userDatabase.get(userId) || null;
  }

  async updateUserStatus(adminId: string, userId: string, status: 'active' | 'suspended' | 'banned', reason?: string): Promise<boolean> {
    if (!this.checkAdminPermission(adminId, 'users', 'write')) {
      throw new Error('Insufficient permissions');
    }

    const user = this.userDatabase.get(userId);
    if (!user) return false;

    user.status = status;
    
    // Add flag for status change
    if (status !== 'active' && reason) {
      user.flags.push({
        type: status === 'suspended' ? 'suspicious_activity' : 'multiple_accounts',
        severity: 'high',
        description: reason,
        createdAt: new Date().toISOString()
      });
    }

    return true;
  }

  async addUserFlag(adminId: string, userId: string, flag: Omit<UserFlag, 'createdAt'>): Promise<boolean> {
    if (!this.checkAdminPermission(adminId, 'users', 'write')) {
      throw new Error('Insufficient permissions');
    }

    const user = this.userDatabase.get(userId);
    if (!user) return false;

    user.flags.push({
      ...flag,
      createdAt: new Date().toISOString()
    });

    return true;
  }

  /**
   * Contest Management
   */
  async getAllContests(page: number = 1, limit: number = 50, filters?: {
    status?: string;
    type?: string;
    dateFrom?: string;
    dateTo?: string;
  }): Promise<{ contests: ContestSummary[]; total: number; page: number; totalPages: number }> {
    // Get contests from contest scoring service
    const allContests = contestScoringService.getAllContests();
    
    let contests: ContestSummary[] = allContests.map(contest => ({
      id: contest.id,
      name: contest.name,
      type: contest.type,
      status: contest.status as 'pending' | 'active' | 'completed' | 'cancelled',
      participantCount: contest.participants.length,
      maxParticipants: contest.maxParticipants || 0,
      entryFee: contest.entryFee,
      prizePool: contest.prizePool.totalPrize,
      startDate: contest.startDate,
      endDate: contest.endDate,
      creator: 'system',
      flags: this.generateContestFlags(contest)
    }));

    // Apply filters
    if (filters) {
      if (filters.status) {
        contests = contests.filter(c => c.status === filters.status);
      }
      if (filters.type) {
        contests = contests.filter(c => c.type === filters.type);
      }
    }

    const total = contests.length;
    const totalPages = Math.ceil(total / limit);
    const startIndex = (page - 1) * limit;
    const paginatedContests = contests.slice(startIndex, startIndex + limit);

    return {
      contests: paginatedContests,
      total,
      page,
      totalPages
    };
  }

  private generateContestFlags(_contest: unknown): ContestFlag[] {
    const flags: ContestFlag[] = [];
    
    // Simplified implementation - return empty flags for now
    return flags;
  }

  async createContest(_adminId: string, _contestData: unknown): Promise<string> {
    // Simplified implementation
    return 'generated-contest-id';
  }

  async cancelContest(adminId: string, contestId: string, reason: string): Promise<boolean> {
    if (!this.checkAdminPermission(adminId, 'contests', 'delete')) {
      throw new Error('Insufficient permissions');
    }

    // In production, this would cancel the contest and handle refunds
    logger.info(`Contest ${contestId} cancelled by admin ${adminId}: ${reason}`);
    return true;
  }

  /**
   * Payment Management
   */
  async getAllPayments(page: number = 1, limit: number = 50, filters?: {
    type?: string;
    status?: string;
    dateFrom?: string;
    dateTo?: string;
    userId?: string;
  }): Promise<{ payments: PaymentSummary[]; total: number; page: number; totalPages: number }> {
    // Generate sample payment data
    const samplePayments: PaymentSummary[] = [
      {
        id: 'pay_001',
        userId: 'user_001',
        type: 'deposit',
        amount: 100,
        currency: 'USD',
        status: 'completed',
        method: 'credit_card',
        createdAt: '2024-12-20T10:00:00Z',
        processedAt: '2024-12-20T10:05:00Z',
        flags: []
      },
      {
        id: 'pay_002',
        userId: 'user_002',
        type: 'contest_entry',
        amount: 25,
        currency: 'USD',
        status: 'completed',
        method: 'account_balance',
        createdAt: '2024-12-20T11:30:00Z',
        processedAt: '2024-12-20T11:30:00Z',
        flags: []
      },
      {
        id: 'pay_003',
        userId: 'user_003',
        type: 'deposit',
        amount: 1500,
        currency: 'USD',
        status: 'disputed',
        method: 'credit_card',
        createdAt: '2024-12-18T15:00:00Z',
        flags: [
          {
            type: 'large_amount',
            severity: 'medium',
            description: 'Large deposit amount flagged for review',
            autoGenerated: true
          },
          {
            type: 'chargeback_risk',
            severity: 'high',
            description: 'Chargeback initiated by cardholder',
            autoGenerated: false
          }
        ]
      }
    ];

    let payments = samplePayments;

    // Apply filters
    if (filters) {
      if (filters.type) {
        payments = payments.filter(p => p.type === filters.type);
      }
      if (filters.status) {
        payments = payments.filter(p => p.status === filters.status);
      }
      if (filters.userId) {
        payments = payments.filter(p => p.userId === filters.userId);
      }
    }

    const total = payments.length;
    const totalPages = Math.ceil(total / limit);
    const startIndex = (page - 1) * limit;
    const paginatedPayments = payments.slice(startIndex, startIndex + limit);

    return {
      payments: paginatedPayments,
      total,
      page,
      totalPages
    };
  }

  async processRefund(adminId: string, paymentId: string, amount: number, reason: string): Promise<boolean> {
    if (!this.checkAdminPermission(adminId, 'payments', 'execute')) {
      throw new Error('Insufficient permissions');
    }

    // In production, this would process the refund through payment processor
    logger.info(`Refund of $${amount} processed for payment ${paymentId} by admin ${adminId}: ${reason}`);
    return true;
  }

  /**
   * Oracle Management
   */
  async getOracleMetrics(): Promise<OracleMetrics> {
    // Mock Oracle performance data since geminiService is not available
    const mockStats = {
      totalRequests: 127,
      errors: []
    };
    
    return {
      totalPredictions: mockStats.totalRequests,
      accuracyRate: 0.72, // This would be calculated from actual prediction results
      averageConfidence: 0.78,
      apiUsage: {
        requests: mockStats.totalRequests,
        successRate: mockStats.totalRequests > 0 ? (mockStats.totalRequests - (mockStats.errors?.length || 0)) / mockStats.totalRequests : 1,
        avgResponseTime: 1250, // ms
        errorRate: mockStats.errors?.length || 0
      },
      performanceByCategory: {
        'Game Lines': { predictions: 45, accuracy: 0.73, confidence: 0.82 },
        'Player Props': { predictions: 32, accuracy: 0.68, confidence: 0.75 },
        'Team Stats': { predictions: 28, accuracy: 0.75, confidence: 0.80 }
      },
      userEngagement: {
        followingOracle: 15,
        averageAgreementRate: 0.65,
        oracleBeatRate: 0.28
      }
    };
  }

  async updateOracleConfig(adminId: string, config: Record<string, unknown>): Promise<boolean> {
    if (!this.checkAdminPermission(adminId, 'oracle', 'write')) {
      throw new Error('Insufficient permissions');
    }

    // In production, this would update Oracle configuration
    logger.info(`Oracle configuration updated by admin ${adminId}:`, config);
    return true;
  }

  async triggerOracleRetrain(adminId: string): Promise<boolean> {
    if (!this.checkAdminPermission(adminId, 'oracle', 'execute')) {
      throw new Error('Insufficient permissions');
    }

    // In production, this would trigger Oracle model retraining
    logger.info(`Oracle retraining triggered by admin ${adminId}`);
    return true;
  }

  /**
   * System Analytics
   */
  async getSystemMetrics(): Promise<SystemMetrics> {
    const uptime = Date.now() - this.startTime;
    const sportsDataStatus = productionSportsDataService.getAPIStatus();
    
    return {
      uptime,
      activeUsers: 8,
      totalUsers: this.userDatabase.size,
      activeContests: contestScoringService.getActiveContests().length,
      totalRevenue: 12450,
      todayRevenue: 340,
      systemHealth: {
        database: 'healthy',
        apis: sportsDataStatus.isConnected ? 'healthy' : 'warning',
        payments: 'healthy',
        oracle: 'healthy'
      },
      errors: this.systemErrors
    };
  }

  async getDashboardData(): Promise<AdminDashboardData> {
    const metrics = await this.getSystemMetrics();
    const allUsers = await this.getAllUsers(1, 10);
    const allContests = await this.getAllContests(1, 5);
    const allPayments = await this.getAllPayments(1, 5);

    return {
      overview: {
        totalUsers: metrics.totalUsers,
        activeUsers: metrics.activeUsers,
        totalContests: contestScoringService.getAllContests().length,
        activeContests: metrics.activeContests,
        totalRevenue: metrics.totalRevenue,
        todayRevenue: metrics.todayRevenue,
        pendingIssues: this.systemErrors.filter(e => !e.resolved).length,
        systemHealth: this.calculateOverallHealth(metrics.systemHealth)
      },
      recentActivity: {
        newUsers: allUsers.users.slice(0, 5),
        recentContests: allContests.contests.slice(0, 3),
        recentPayments: allPayments.payments.slice(0, 5),
        systemAlerts: this.systemErrors.filter(e => !e.resolved).slice(0, 5)
      },
      metrics: {
        userGrowth: this.generateMockGrowthData('users') as { date: string; count: number }[],
        revenueGrowth: this.generateMockGrowthData('revenue') as { date: string; amount: number }[],
        contestParticipation: this.generateMockGrowthData('participation') as { date: string; participants: number }[],
        oracleAccuracy: this.generateMockGrowthData('accuracy') as { date: string; accuracy: number }[]
      }
    };
  }

  private calculateOverallHealth(health: SystemMetrics['systemHealth']): 'healthy' | 'warning' | 'critical' {
    const values = Object.values(health);
    if (values.includes('critical')) return 'critical';
    if (values.includes('warning')) return 'warning';
    return 'healthy';
  }

  private generateMockGrowthData(type: string): Record<string, unknown>[] {
    const data: Record<string, unknown>[] = [];
    const today = new Date();
    
    for (let i = 29; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(date.getDate() - i);
      
      const entry = { date: date.toISOString().split('T')[0] } as Record<string, unknown>;
      
      switch (type) {
        case 'users':
          entry.count = Math.floor(Math.random() * 5) + 1;
          break;
        case 'revenue':
          entry.amount = Math.floor(Math.random() * 1000) + 500;
          break;
        case 'contests':
          entry.participants = Math.floor(Math.random() * 50) + 10;
          break;
        case 'oracle':
          entry.accuracy = Math.random() * 0.2 + 0.75;
          break;
      }
      
      data.push(entry);
    }
    
    return data;
  }

  /**
   * System Error Management
   */
  logSystemError(error: Omit<SystemError, 'id' | 'count' | 'firstOccurrence' | 'lastOccurrence' | 'resolved'>): void {
    const existingError = this.systemErrors.find(e => 
      e.type === error.type && e.message === error.message && !e.resolved
    );

    if (existingError) {
      existingError.count++;
      existingError.lastOccurrence = new Date().toISOString();
    } else {
      const newError: SystemError = {
        ...error,
        id: `error_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`,
        count: 1,
        firstOccurrence: new Date().toISOString(),
        lastOccurrence: new Date().toISOString(),
        resolved: false
      };
      this.systemErrors.push(newError);
    }
  }

  async resolveSystemError(adminId: string, errorId: string): Promise<boolean> {
    if (!this.checkAdminPermission(adminId, 'system', 'write')) {
      throw new Error('Insufficient permissions');
    }

    const error = this.systemErrors.find(e => e.id === errorId);
    if (error) {
      error.resolved = true;
      return true;
    }
    return false;
  }

  /**
   * Backup and Maintenance
   */
  async createSystemBackup(adminId: string): Promise<string> {
    if (!this.checkAdminPermission(adminId, 'system', 'execute')) {
      throw new Error('Insufficient permissions');
    }

    const backupId = `backup_${Date.now()}`;
    logger.info(`System backup ${backupId} created by admin ${adminId}`);
    return backupId;
  }

  async runSystemMaintenance(adminId: string, maintenanceType: 'cache_clear' | 'db_optimize' | 'log_rotation'): Promise<boolean> {
    if (!this.checkAdminPermission(adminId, 'system', 'execute')) {
      throw new Error('Insufficient permissions');
    }

    logger.info(`System maintenance (${maintenanceType}) executed by admin ${adminId}`);
    return true;
  }
}

// Export singleton instance
export const adminService = new AdminService();
export default adminService;
