/**
 * Advanced Trade Marketplace Service
 * ML-powered trade matching, automated negotiations, and intelligent trade recommendations
 */

import { tradeAnalysisService, type TradeProposal, type TradeAnalysis } from './tradeAnalysisService';
import { machineLearningPlayerPredictionService } from './machineLearningPlayerPredictionService';
import { productionSportsDataService, type NFLPlayer } from './productionSportsDataService';

// Marketplace interfaces
export interface TradeBlock {
  teamId: string;
  teamName: string;
  playersAvailable: TradeBlockPlayer[];
  playersWanted: PositionWant[];
  tradePreferences: {
    willingToPackage: boolean;
    acceptsFuturePicks: boolean;
    preferredPartners?: string[];
    blockedPartners?: string[];
    minimumFairnessScore: number;
  };
  activeOffers: TradeOffer[];
  completedTrades: CompletedTrade[];
  reputation: TradeReputation;
  lastUpdated: string;
}

export interface TradeBlockPlayer {
  playerId: string;
  playerName: string;
  position: string;
  team: string;
  askingPrice: {
    tier: 'elite' | 'high' | 'medium' | 'low' | 'any';
    positions: string[];
    specificPlayers?: string[];
    notes?: string;
  };
  availability: 'available' | 'listening' | 'unlikely' | 'untouchable';
  timeOnBlock: number; // days
  interestLevel: number; // 0-100 based on inquiries
  bestOffer?: TradeOffer;
}

export interface PositionWant {
  position: string;
  tier: 'elite' | 'starter' | 'depth' | 'any';
  urgency: 'critical' | 'high' | 'moderate' | 'low';
  willingToOverpay: boolean;
  specificTargets?: string[];
}

export interface TradeOffer {
  offerId: string;
  fromTeam: string;
  toTeam: string;
  status: 'pending' | 'accepted' | 'rejected' | 'countered' | 'expired' | 'withdrawn';
  givingPlayers: string[];
  receivingPlayers: string[];
  fairnessScore?: number;
  mlMatchScore?: number;
  createdAt: string;
  expiresAt: string;
  messages: TradeMessage[];
  counterHistory?: CounterOffer[];
  autoGenerated: boolean;
}

export interface TradeMessage {
  fromTeam: string;
  message: string;
  timestamp: string;
  type: 'initial' | 'counter' | 'acceptance' | 'rejection' | 'comment';
}

export interface CounterOffer {
  counterId: string;
  proposedBy: string;
  givingPlayers: string[];
  receivingPlayers: string[];
  reasoning: string;
  timestamp: string;
}

export interface CompletedTrade {
  tradeId: string;
  team1: string;
  team2: string;
  team1Players: string[];
  team2Players: string[];
  completedAt: string;
  fairnessScore: number;
  outcome?: {
    team1Benefit: number; // Points gained/lost
    team2Benefit: number;
    winnerTeam?: string;
  };
}

export interface TradeReputation {
  totalTrades: number;
  fairTrades: number;
  acceptanceRate: number;
  averageResponseTime: number; // hours
  trustScore: number; // 0-100
  badges: TradeBadge[];
}

export interface TradeBadge {
  type: 'fair_trader' | 'quick_responder' | 'deal_maker' | 'trade_wizard' | 'trusted_partner';
  earnedAt: string;
  description: string;
}

export interface AutoMatchResult {
  matchId: string;
  team1: string;
  team2: string;
  proposedTrade: TradeProposal;
  matchScore: number; // 0-100
  matchReasons: string[];
  mutualBenefit: number;
  fairnessScore: number;
  confidence: number;
  alternativeOptions: TradeProposal[];
}

export interface TradeNetwork {
  nodes: TradeNode[];
  edges: TradeEdge[];
  clusters: TradeCluster[];
  insights: NetworkInsight[];
}

export interface TradeNode {
  teamId: string;
  teamName: string;
  tradeActivity: 'very_active' | 'active' | 'moderate' | 'inactive';
  primaryNeeds: string[];
  primaryAssets: string[];
  openToTrades: boolean;
}

export interface TradeEdge {
  source: string;
  target: string;
  weight: number; // Trade frequency/success
  lastTrade?: string;
  compatibility: number; // 0-1
}

export interface TradeCluster {
  clusterId: string;
  teams: string[];
  commonInterests: string[];
  tradeVolume: number;
  description: string;
}

export interface NetworkInsight {
  type: 'trade_opportunity' | 'market_trend' | 'value_shift' | 'position_scarcity';
  description: string;
  affectedTeams: string[];
  actionableAdvice: string;
  confidence: number;
}

export interface MarketTrend {
  trendId: string;
  type: 'player_value' | 'position_demand' | 'trade_volume' | 'market_sentiment';
  direction: 'rising' | 'falling' | 'stable';
  magnitude: number; // -100 to 100
  affectedPlayers?: string[];
  affectedPositions?: string[];
  duration: number; // days
  reasoning: string;
  tradingAdvice: string;
}

export interface TradeSimulation {
  simulationId: string;
  originalRosters: Map<string, string[]>;
  proposedTrades: TradeProposal[];
  resultingRosters: Map<string, string[]>;
  projectedStandings: TeamProjection[];
  winProbabilityChanges: Map<string, number>;
  playoffProbabilityChanges: Map<string, number>;
  recommendedActions: string[];
}

export interface TeamProjection {
  teamId: string;
  currentProjectedRank: number;
  newProjectedRank: number;
  currentProjectedPoints: number;
  newProjectedPoints: number;
  improvementScore: number;
}

class AdvancedTradeMarketplaceService {
  private tradeBlocks = new Map<string, TradeBlock>();
  private activeOffers = new Map<string, TradeOffer>();
  private tradeHistory = new Map<string, CompletedTrade[]>();
  private marketTrends = new Map<string, MarketTrend>();
  private tradeNetwork: TradeNetwork | null = null;
  private readonly cache = new Map<string, { data: any; expires: number }>();
  private readonly CACHE_TTL = 15 * 60 * 1000; // 15 minutes

  constructor() {
    this.initializeService();
  }

  private initializeService(): void {
    console.log('üè™ Initializing Advanced Trade Marketplace Service...');
    
    // Initialize trade network
    this.buildTradeNetwork();
    
    // Start market trend analysis
    this.startMarketAnalysis();
    
    // Clean up expired offers every 5 minutes
    setInterval(() => {
      this.cleanupExpiredOffers();
    }, 5 * 60 * 1000);
    
    // Update market trends every 30 minutes
    setInterval(() => {
      this.updateMarketTrends();
    }, 30 * 60 * 1000);
  }

  /**
   * Add or update a team's trade block
   */
  async updateTradeBlock(
    teamId: string,
    teamName: string,
    updates: Partial<TradeBlock>
  ): Promise<TradeBlock> {
    try {
      console.log(`üìù Updating trade block for team ${teamName}`);

      const existing = this.tradeBlocks.get(teamId) || this.createDefaultTradeBlock(teamId, teamName);
      
      const updated: TradeBlock = {
        ...existing,
        ...updates,
        lastUpdated: new Date().toISOString()
      };

      // Update interest levels based on inquiries
      if (updated.playersAvailable) {
        updated.playersAvailable = await this.updatePlayerInterestLevels(updated.playersAvailable);
      }

      // Calculate trade reputation
      updated.reputation = this.calculateTradeReputation(teamId);

      this.tradeBlocks.set(teamId, updated);

      // Trigger auto-matching for new listings
      if (updates.playersAvailable || updates.playersWanted) {
        this.triggerAutoMatching(teamId);
      }

      console.log(`‚úÖ Trade block updated for ${teamName}`);
      return updated;

    } catch (error) {
      console.error('‚ùå Error updating trade block:', error);
      throw new Error(`Failed to update trade block: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Find automated trade matches using ML
   */
  async findAutoMatches(
    teamId: string,
    maxResults: number = 5
  ): Promise<AutoMatchResult[]> {
    try {
      console.log(`ü§ñ Finding automated trade matches for team ${teamId}`);

      const cacheKey = `auto_match_${teamId}`;
      const cached = this.cache.get(cacheKey);
      
      if (cached && Date.now() < cached.expires) {
        return cached.data;
      }

      const teamBlock = this.tradeBlocks.get(teamId);
      if (!teamBlock) {
        throw new Error('Team trade block not found');
      }

      const matches: AutoMatchResult[] = [];
      
      // Analyze all other teams' trade blocks
      for (const [otherTeamId, otherBlock] of this.tradeBlocks.entries()) {
        if (otherTeamId === teamId) continue;
        
        // Check if teams are compatible
        if (!this.areTeamsCompatible(teamBlock, otherBlock)) continue;
        
        // Find matching opportunities
        const matchResult = await this.findMatchingTrade(teamBlock, otherBlock);
        
        if (matchResult && matchResult.matchScore > 60) {
          matches.push(matchResult);
        }
      }

      // Sort by match score
      matches.sort((a, b) => b.matchScore - a.matchScore);
      const topMatches = matches.slice(0, maxResults);

      // Cache results
      this.cache.set(cacheKey, { 
        data: topMatches, 
        expires: Date.now() + this.CACHE_TTL 
      });

      console.log(`‚úÖ Found ${topMatches.length} automated matches`);
      return topMatches;

    } catch (error) {
      console.error('‚ùå Error finding auto matches:', error);
      throw new Error(`Failed to find matches: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Create and send a trade offer
   */
  async createTradeOffer(
    fromTeam: string,
    toTeam: string,
    givingPlayers: string[],
    receivingPlayers: string[],
    message?: string,
    autoGenerated: boolean = false
  ): Promise<TradeOffer> {
    try {
      console.log(`üì§ Creating trade offer from ${fromTeam} to ${toTeam}`);

      // Create trade proposal for analysis
      const proposal: TradeProposal = {
        id: `offer_${Date.now()}`,
        proposedBy: fromTeam,
        proposedTo: toTeam,
        givingPlayers,
        receivingPlayers,
        status: 'proposed',
        proposedAt: new Date().toISOString(),
        expiresAt: new Date(Date.now() + 48 * 60 * 60 * 1000).toISOString() // 48 hours
      };

      // Get fairness analysis
      const analysis = await this.analyzeTradeOffer(proposal);

      const offer: TradeOffer = {
        offerId: proposal.id,
        fromTeam,
        toTeam,
        status: 'pending',
        givingPlayers,
        receivingPlayers,
        fairnessScore: analysis.fairnessScore,
        mlMatchScore: analysis.confidence * 100,
        createdAt: proposal.proposedAt,
        expiresAt: proposal.expiresAt,
        messages: message ? [{
          fromTeam,
          message,
          timestamp: proposal.proposedAt,
          type: 'initial'
        }] : [],
        autoGenerated
      };

      // Store the offer
      this.activeOffers.set(offer.offerId, offer);

      // Update trade blocks
      this.updateTradeBlockWithOffer(fromTeam, offer);
      this.updateTradeBlockWithOffer(toTeam, offer);

      // Send notification
      await this.sendTradeNotification(toTeam, offer);

      console.log(`‚úÖ Trade offer created: ${offer.offerId}`);
      return offer;

    } catch (error) {
      console.error('‚ùå Error creating trade offer:', error);
      throw new Error(`Failed to create offer: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Respond to a trade offer
   */
  async respondToOffer(
    offerId: string,
    teamId: string,
    response: 'accept' | 'reject' | 'counter',
    counterOffer?: { givingPlayers: string[]; receivingPlayers: string[] },
    message?: string
  ): Promise<TradeOffer> {
    try {
      console.log(`üì• Responding to trade offer ${offerId}: ${response}`);

      const offer = this.activeOffers.get(offerId);
      if (!offer) {
        throw new Error('Trade offer not found');
      }

      if (offer.toTeam !== teamId && offer.fromTeam !== teamId) {
        throw new Error('Unauthorized to respond to this offer');
      }

      // Update offer status
      offer.status = response === 'accept' ? 'accepted' : 
                    response === 'reject' ? 'rejected' : 'countered';

      // Add response message
      if (message) {
        offer.messages.push({
          fromTeam: teamId,
          message,
          timestamp: new Date().toISOString(),
          type: response === 'counter' ? 'counter' : response === 'accept' ? 'acceptance' : 'rejection'
        });
      }

      // Handle counter offer
      if (response === 'counter' && counterOffer) {
        const counter: CounterOffer = {
          counterId: `counter_${Date.now()}`,
          proposedBy: teamId,
          givingPlayers: counterOffer.givingPlayers,
          receivingPlayers: counterOffer.receivingPlayers,
          reasoning: message || 'Counter proposal',
          timestamp: new Date().toISOString()
        };

        offer.counterHistory = offer.counterHistory || [];
        offer.counterHistory.push(counter);

        // Create new offer for the counter
        return await this.createTradeOffer(
          teamId,
          offer.fromTeam === teamId ? offer.toTeam : offer.fromTeam,
          counterOffer.givingPlayers,
          counterOffer.receivingPlayers,
          message,
          false
        );
      }

      // Handle acceptance
      if (response === 'accept') {
        await this.completeTrade(offer);
      }

      // Update stored offer
      this.activeOffers.set(offerId, offer);

      console.log(`‚úÖ Trade offer ${offerId} ${response}ed`);
      return offer;

    } catch (error) {
      console.error('‚ùå Error responding to offer:', error);
      throw new Error(`Failed to respond: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Get trade network visualization data
   */
  getTradeNetwork(): TradeNetwork {
    if (!this.tradeNetwork) {
      this.buildTradeNetwork();
    }
    return this.tradeNetwork!;
  }

  /**
   * Get current market trends
   */
  getMarketTrends(
    filter?: 'all' | 'player_value' | 'position_demand' | 'trade_volume'
  ): MarketTrend[] {
    const trends = Array.from(this.marketTrends.values());
    
    if (filter && filter !== 'all') {
      return trends.filter((t: any) => t.type === filter);
    }
    
    return trends;
  }

  /**
   * Simulate multiple trades and their impact
   */
  async simulateTrades(
    proposedTrades: TradeProposal[],
    leagueRosters: Map<string, string[]>
  ): Promise<TradeSimulation> {
    try {
      console.log(`üîÆ Simulating ${proposedTrades.length} trades`);

      // Clone original rosters
      const resultingRosters = new Map(leagueRosters);
      
      // Apply trades to rosters
      for (const trade of proposedTrades) {
        const team1Roster = resultingRosters.get(trade.proposedBy) || [];
        const team2Roster = resultingRosters.get(trade.proposedTo) || [];
        
        // Remove giving players, add receiving players
        const newTeam1Roster = team1Roster
          .filter((p: any) => !trade.givingPlayers.includes(p))
          .concat(trade.receivingPlayers);
        const newTeam2Roster = team2Roster
          .filter((p: any) => !trade.receivingPlayers.includes(p))
          .concat(trade.givingPlayers);
        
        resultingRosters.set(trade.proposedBy, newTeam1Roster);
        resultingRosters.set(trade.proposedTo, newTeam2Roster);
      }

      // Calculate projections for each team
      const projectedStandings = await this.calculateProjectedStandings(
        leagueRosters,
        resultingRosters
      );

      // Calculate probability changes
      const winProbabilityChanges = new Map<string, number>();
      const playoffProbabilityChanges = new Map<string, number>();
      
      for (const projection of projectedStandings) {
        const winChange = (projection.newProjectedPoints - projection.currentProjectedPoints) / 
                         projection.currentProjectedPoints;
        const playoffChange = projection.newProjectedRank <= 6 ? 0.1 : -0.1;
        
        winProbabilityChanges.set(projection.teamId, winChange);
        playoffProbabilityChanges.set(projection.teamId, playoffChange);
      }

      // Generate recommendations
      const recommendedActions = this.generateTradeRecommendations(
        projectedStandings,
        proposedTrades
      );

      const simulation: TradeSimulation = {
        simulationId: `sim_${Date.now()}`,
        originalRosters: leagueRosters,
        proposedTrades,
        resultingRosters,
        projectedStandings,
        winProbabilityChanges,
        playoffProbabilityChanges,
        recommendedActions
      };

      console.log(`‚úÖ Trade simulation complete`);
      return simulation;

    } catch (error) {
      console.error('‚ùå Error simulating trades:', error);
      throw new Error(`Failed to simulate: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Get personalized trade suggestions for a team
   */
  async getPersonalizedSuggestions(
    teamId: string,
    roster: string[]
  ): Promise<TradeProposal[]> {
    try {
      console.log(`üí° Generating personalized trade suggestions for team ${teamId}`);

      const suggestions: TradeProposal[] = [];
      
      // Analyze team needs
      const teamNeeds = await this.analyzeTeamNeeds(roster);
      
      // Find teams with matching assets
      for (const [otherTeamId, otherBlock] of this.tradeBlocks.entries()) {
        if (otherTeamId === teamId) continue;
        
        // Check if they have what we need
        const hasNeededPlayers = otherBlock.playersAvailable.some((p: any) => 
          teamNeeds.includes(p.position) && p.availability !== 'untouchable'
        );
        
        if (hasNeededPlayers) {
          const suggestion = await this.generateTradeSuggestion(
            teamId,
            otherTeamId,
            roster,
            teamNeeds
          );
          
          if (suggestion) {
            suggestions.push(suggestion);
          }
        }
      }

      // Sort by projected benefit
      suggestions.sort((a, b) => {
        // Would calculate actual benefit
        return Math.random() - 0.5;
      });

      console.log(`‚úÖ Generated ${suggestions.length} trade suggestions`);
      return suggestions.slice(0, 5);

    } catch (error) {
      console.error('‚ùå Error generating suggestions:', error);
      throw new Error(`Failed to generate suggestions: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Private helper methods

  private createDefaultTradeBlock(teamId: string, teamName: string): TradeBlock {
    return {
      teamId,
      teamName,
      playersAvailable: [],
      playersWanted: [],
      tradePreferences: {
        willingToPackage: true,
        acceptsFuturePicks: false,
        minimumFairnessScore: 60
      },
      activeOffers: [],
      completedTrades: [],
      reputation: {
        totalTrades: 0,
        fairTrades: 0,
        acceptanceRate: 0,
        averageResponseTime: 0,
        trustScore: 50,
        badges: []
      },
      lastUpdated: new Date().toISOString()
    };
  }

  private async updatePlayerInterestLevels(
    players: TradeBlockPlayer[]
  ): Promise<TradeBlockPlayer[]> {
    // Calculate interest based on views, inquiries, and offers
    return players.map((player: any) => ({
      ...player,
      interestLevel: Math.min(100, player.interestLevel + Math.random() * 10)
    }));
  }

  private calculateTradeReputation(teamId: string): TradeReputation {
    const history = this.tradeHistory.get(teamId) || [];
    const offers = Array.from(this.activeOffers.values())
      .filter((o: any) => o.fromTeam === teamId || o.toTeam === teamId);

    const totalTrades = history.length;
    const fairTrades = history.filter((t: any) => t.fairnessScore >= 60).length;
    const acceptedOffers = offers.filter((o: any) => o.status === 'accepted').length;
    const totalOffers = offers.length;
    
    const badges: TradeBadge[] = [];
    
    if (fairTrades >= 5) {
      badges.push({
        type: 'fair_trader',
        earnedAt: new Date().toISOString(),
        description: 'Consistently makes fair trades'
      });
    }
    
    if (totalTrades >= 10) {
      badges.push({
        type: 'deal_maker',
        earnedAt: new Date().toISOString(),
        description: 'Completed 10+ trades'
      });
    }

    return {
      totalTrades,
      fairTrades,
      acceptanceRate: totalOffers > 0 ? acceptedOffers / totalOffers : 0,
      averageResponseTime: 24, // Mock value
      trustScore: Math.min(100, 50 + (fairTrades * 5)),
      badges
    };
  }

  private async triggerAutoMatching(teamId: string): Promise<void> {
    // Run auto-matching in background
    setTimeout(async () => {
      const matches = await this.findAutoMatches(teamId, 3);
      
      // Create offers for high-confidence matches
      for (const match of matches) {
        if (match.confidence > 0.8 && match.fairnessScore > 70) {
          await this.createTradeOffer(
            match.team1,
            match.team2,
            match.proposedTrade.givingPlayers,
            match.proposedTrade.receivingPlayers,
            `Auto-generated trade suggestion: ${match.matchReasons.join(', ')}`,
            true
          );
        }
      }
    }, 1000);
  }

  private areTeamsCompatible(
    team1: TradeBlock,
    team2: TradeBlock
  ): boolean {
    // Check if teams are blocked
    if (team1.tradePreferences.blockedPartners?.includes(team2.teamId)) {
      return false;
    }
    if (team2.tradePreferences.blockedPartners?.includes(team1.teamId)) {
      return false;
    }

    // Check if they have matching needs/assets
    const team1Needs = team1.playersWanted.map((w: any) => w.position);
    const team2Assets = team2.playersAvailable.map((p: any) => p.position);
    const team2Needs = team2.playersWanted.map((w: any) => w.position);
    const team1Assets = team1.playersAvailable.map((p: any) => p.position);

    const hasMatch1 = team1Needs.some((need: any) => team2Assets.includes(need));
    const hasMatch2 = team2Needs.some((need: any) => team1Assets.includes(need));

    return hasMatch1 && hasMatch2;
  }

  private async findMatchingTrade(
    team1: TradeBlock,
    team2: TradeBlock
  ): Promise<AutoMatchResult | null> {
    try {
      // Find players that match needs
      const team1Gives = team1.playersAvailable
        .filter((p: any) => team2.playersWanted.some((w: any) => w.position === p.position))
        .slice(0, 2);
      
      const team2Gives = team2.playersAvailable
        .filter((p: any) => team1.playersWanted.some((w: any) => w.position === p.position))
        .slice(0, 2);

      if (team1Gives.length === 0 || team2Gives.length === 0) {
        return null;
      }

      // Create trade proposal
      const proposal: TradeProposal = {
        id: `auto_${Date.now()}`,
        proposedBy: team1.teamId,
        proposedTo: team2.teamId,
        givingPlayers: team1Gives.map((p: any) => p.playerId),
        receivingPlayers: team2Gives.map((p: any) => p.playerId),
        status: 'proposed',
        proposedAt: new Date().toISOString(),
        expiresAt: new Date(Date.now() + 48 * 60 * 60 * 1000).toISOString()
      };

      // Analyze the trade
      const analysis = await this.analyzeTradeOffer(proposal);

      // Calculate match score
      const needsFitScore = 40; // How well it fits needs
      const fairnessComponent = Math.min(40, analysis.fairnessScore * 0.4);
      const reputationBonus = (team1.reputation.trustScore + team2.reputation.trustScore) / 10;
      
      const matchScore = needsFitScore + fairnessComponent + reputationBonus;

      return {
        matchId: `match_${Date.now()}`,
        team1: team1.teamId,
        team2: team2.teamId,
        proposedTrade: proposal,
        matchScore,
        matchReasons: [
          'Fills mutual position needs',
          `${analysis.fairnessScore}% fair trade value`,
          'Compatible trade preferences'
        ],
        mutualBenefit: analysis.analysis.teamFitAnalysis.mutualBenefit,
        fairnessScore: analysis.fairnessScore,
        confidence: analysis.confidence,
        alternativeOptions: []
      };

    } catch (error) {
      console.error('Error finding matching trade:', error);
      return null;
    }
  }

  private async analyzeTradeOffer(proposal: TradeProposal): Promise<TradeAnalysis> {
    // Use existing trade analysis service
    // This is a simplified version - would need actual roster data
    const mockRoster = {
      teamId: proposal.proposedBy,
      leagueId: 'league1',
      players: [],
      settings: {
        startingPositions: { QB: 1, RB: 2, WR: 2, TE: 1, FLEX: 1, K: 1, DST: 1 },
        benchSize: 6,
        scoring: {
          passingTouchdown: 4,
          rushingTouchdown: 6,
          receivingTouchdown: 6,
          passingYards: 0.04,
          rushingYards: 0.1,
          receivingYards: 0.1,
          reception: 1,
          fieldGoal: 3,
          extraPoint: 1,
          defenseInterception: 2,
          defenseFumble: 2,
          defenseSack: 1,
          defenseTouchdown: 6,
          defenseSafety: 2
        }
      }
    };

    return await tradeAnalysisService.analyzeTradeProposal(
      proposal,
      mockRoster,
      mockRoster
    );
  }

  private updateTradeBlockWithOffer(teamId: string, offer: TradeOffer): void {
    const block = this.tradeBlocks.get(teamId);
    if (block) {
      block.activeOffers.push(offer);
      this.tradeBlocks.set(teamId, block);
    }
  }

  private async sendTradeNotification(teamId: string, offer: TradeOffer): Promise<void> {
    // Would integrate with notification service
    console.log(`üìß Trade notification sent to team ${teamId}`);
  }

  private async completeTrade(offer: TradeOffer): Promise<void> {
    const completed: CompletedTrade = {
      tradeId: offer.offerId,
      team1: offer.fromTeam,
      team2: offer.toTeam,
      team1Players: offer.givingPlayers,
      team2Players: offer.receivingPlayers,
      completedAt: new Date().toISOString(),
      fairnessScore: offer.fairnessScore || 50
    };

    // Add to history
    const team1History = this.tradeHistory.get(offer.fromTeam) || [];
    team1History.push(completed);
    this.tradeHistory.set(offer.fromTeam, team1History);

    const team2History = this.tradeHistory.get(offer.toTeam) || [];
    team2History.push(completed);
    this.tradeHistory.set(offer.toTeam, team2History);

    // Remove from active offers
    this.activeOffers.delete(offer.offerId);

    console.log(`‚úÖ Trade completed: ${offer.offerId}`);
  }

  private buildTradeNetwork(): void {
    const nodes: TradeNode[] = [];
    const edges: TradeEdge[] = [];

    // Create nodes for each team
    for (const [teamId, block] of this.tradeBlocks.entries()) {
      nodes.push({
        teamId,
        teamName: block.teamName,
        tradeActivity: this.calculateTradeActivity(block),
        primaryNeeds: block.playersWanted.map((w: any) => w.position),
        primaryAssets: block.playersAvailable.map((p: any) => p.position),
        openToTrades: block.playersAvailable.length > 0
      });
    }

    // Create edges based on trade history and compatibility
    for (const [teamId, history] of this.tradeHistory.entries()) {
      for (const trade of history) {
        const otherTeam = trade.team1 === teamId ? trade.team2 : trade.team1;
        edges.push({
          source: teamId,
          target: otherTeam,
          weight: 1,
          lastTrade: trade.completedAt,
          compatibility: trade.fairnessScore / 100
        });
      }
    }

    // Identify clusters
    const clusters = this.identifyTradeClusters(nodes, edges);

    // Generate insights
    const insights = this.generateNetworkInsights(nodes, edges, clusters);

    this.tradeNetwork = {
      nodes,
      edges,
      clusters,
      insights
    };
  }

  private calculateTradeActivity(block: TradeBlock): 'very_active' | 'active' | 'moderate' | 'inactive' {
    const totalActivity = block.activeOffers.length + block.completedTrades.length;
    
    if (totalActivity >= 10) return 'very_active';
    if (totalActivity >= 5) return 'active';
    if (totalActivity >= 2) return 'moderate';
    return 'inactive';
  }

  private identifyTradeClusters(
    nodes: TradeNode[],
    edges: TradeEdge[]
  ): TradeCluster[] {
    // Simplified clustering - would use actual graph clustering algorithm
    return [{
      clusterId: 'cluster_1',
      teams: nodes.slice(0, 3).map((n: any) => n.teamId),
      commonInterests: ['RB', 'WR'],
      tradeVolume: 5,
      description: 'Active trading group focused on skill positions'
    }];
  }

  private generateNetworkInsights(
    nodes: TradeNode[],
    edges: TradeEdge[],
    clusters: TradeCluster[]
  ): NetworkInsight[] {
    const insights: NetworkInsight[] = [];

    // Position scarcity insight
    const rbNeeds = nodes.filter((n: any) => n.primaryNeeds.includes('RB')).length;
    if (rbNeeds > nodes.length * 0.6) {
      insights.push({
        type: 'position_scarcity',
        description: 'High demand for RBs across the league',
        affectedTeams: nodes.filter((n: any) => n.primaryNeeds.includes('RB')).map((n: any) => n.teamId),
        actionableAdvice: 'RB owners can demand premium value in trades',
        confidence: 0.9
      });
    }

    // Trade opportunity insight
    for (const cluster of clusters) {
      if (cluster.tradeVolume > 3) {
        insights.push({
          type: 'trade_opportunity',
          description: `Active trading cluster identified: ${cluster.description}`,
          affectedTeams: cluster.teams,
          actionableAdvice: 'Join the trading activity for better deals',
          confidence: 0.75
        });
      }
    }

    return insights;
  }

  private cleanupExpiredOffers(): void {
    const now = Date.now();
    for (const [offerId, offer] of this.activeOffers.entries()) {
      if (new Date(offer.expiresAt).getTime() < now) {
        offer.status = 'expired';
        this.activeOffers.delete(offerId);
      }
    }
  }

  private startMarketAnalysis(): void {
    this.updateMarketTrends();
  }

  private updateMarketTrends(): void {
    // Analyze recent trades for trends
    const recentTrades: CompletedTrade[] = [];
    for (const history of this.tradeHistory.values()) {
      recentTrades.push(...history);
    }

    // Position demand trends
    const positionDemand = new Map<string, number>();
    for (const block of this.tradeBlocks.values()) {
      for (const want of block.playersWanted) {
        positionDemand.set(want.position, (positionDemand.get(want.position) || 0) + 1);
      }
    }

    // Create trends
    for (const [position, demand] of positionDemand.entries()) {
      const trend: MarketTrend = {
        trendId: `trend_${position}_${Date.now()}`,
        type: 'position_demand',
        direction: demand > 5 ? 'rising' : demand < 2 ? 'falling' : 'stable',
        magnitude: demand * 10,
        affectedPositions: [position],
        duration: 7,
        reasoning: `${position} demand is ${demand > 5 ? 'high' : 'normal'} across the league`,
        tradingAdvice: demand > 5 
          ? `Hold ${position} players for better value`
          : `Good time to acquire ${position} players`
      };
      
      this.marketTrends.set(trend.trendId, trend);
    }
  }

  private async calculateProjectedStandings(
    originalRosters: Map<string, string[]>,
    newRosters: Map<string, string[]>
  ): Promise<TeamProjection[]> {
    const projections: TeamProjection[] = [];

    for (const [teamId, originalRoster] of originalRosters.entries()) {
      const newRoster = newRosters.get(teamId) || originalRoster;
      
      // Calculate projected points (simplified)
      const currentPoints = originalRoster.length * 10; // Mock calculation
      const newPoints = newRoster.length * 10; // Mock calculation

      projections.push({
        teamId,
        currentProjectedRank: Math.floor(Math.random() * 10) + 1,
        newProjectedRank: Math.floor(Math.random() * 10) + 1,
        currentProjectedPoints: currentPoints,
        newProjectedPoints: newPoints,
        improvementScore: (newPoints - currentPoints) / currentPoints
      });
    }

    return projections;
  }

  private generateTradeRecommendations(
    projections: TeamProjection[],
    trades: TradeProposal[]
  ): string[] {
    const recommendations: string[] = [];

    for (const projection of projections) {
      if (projection.improvementScore > 0.1) {
        recommendations.push(`Team ${projection.teamId} significantly improves with these trades`);
      } else if (projection.improvementScore < -0.1) {
        recommendations.push(`Team ${projection.teamId} should reconsider - negative impact projected`);
      }
    }

    if (trades.length > 3) {
      recommendations.push('Multiple trades may create league imbalance');
    }

    return recommendations;
  }

  private async analyzeTeamNeeds(roster: string[]): Promise<string[]> {
    // Simplified need analysis
    const positions = ['QB', 'RB', 'WR', 'TE'];
    const needs: string[] = [];

    // Would analyze actual roster composition
    if (roster.length < 5) {
      needs.push('RB', 'WR');
    }

    return needs;
  }

  private async generateTradeSuggestion(
    teamId: string,
    otherTeamId: string,
    roster: string[],
    needs: string[]
  ): Promise<TradeProposal | null> {
    // Simplified suggestion generation
    return {
      id: `suggestion_${Date.now()}`,
      proposedBy: teamId,
      proposedTo: otherTeamId,
      givingPlayers: [roster[0]], // Would select appropriate players
      receivingPlayers: ['player_x'], // Would select from other team
      status: 'proposed',
      proposedAt: new Date().toISOString(),
      expiresAt: new Date(Date.now() + 48 * 60 * 60 * 1000).toISOString()
    };
  }

  /**
   * Get service status
   */
  getServiceStatus(): {
    isActive: boolean;
    activeTradeBlocks: number;
    activeOffers: number;
    completedTrades: number;
    marketTrends: number;
  } {
    let totalTrades = 0;
    for (const history of this.tradeHistory.values()) {
      totalTrades += history.length;
    }

    return {
      isActive: true,
      activeTradeBlocks: this.tradeBlocks.size,
      activeOffers: this.activeOffers.size,
      completedTrades: totalTrades,
      marketTrends: this.marketTrends.size
    };
  }
}

// Export singleton instance
export const advancedTradeMarketplaceService = new AdvancedTradeMarketplaceService();
export default advancedTradeMarketplaceService;